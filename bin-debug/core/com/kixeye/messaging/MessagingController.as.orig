package com.kixeye.messaging
{
	import com.adobe.serialization.json.JSON;
	import com.kixeye.logging.IKXLogger;
	import com.kixeye.logging.KXLog;
	import com.kixeye.messaging.engine.IDisposable;
	import com.kixeye.messaging.engine.IMessagingDelegate;
	import com.kixeye.messaging.engine.IMessagingEngine;
	import com.kixeye.messaging.engine.MessagingConfiguration;
	import com.kixeye.messaging.engine.MessagingDisposable;
	import com.kixeye.messaging.engine.MessagingResponse;
	import com.kixeye.messaging.model.Message;
	import com.kixeye.messaging.model.Thread;
	import com.kixeye.messaging.request.CreateThreadRequest;
	import com.kixeye.messaging.request.MessagingRequest;
	import com.kixeye.messaging.request.MessagingUser;
	import com.kixeye.messaging.request.ReplyToThreadRequest;
	
	import flash.events.EventDispatcher;
	
	/**
	 * This class acts as a basic controller for an IMessagingEngine
	 * implementation, usually MessagingEngine or a sublass of the same.
	 * 
	 * This class provides a few basic functionalities:
	 * 
	 * 1. Keeps a consistent list of Threads.
	 * 2. Keeps the list of Messages in each Thread up to date.
	 * 3. Handles intelligently paging Threads and Messages within Threads. It
	 * will not send requests if the data requested is already loaded.
	 * 4. Provides typed functions, requests, and responses for common
	 * messaging methods.
	 * 
	 * See also:
	 * 
	 * https://kixeye.atlassian.net/wiki/display/PF/Comms+JS+API
	 * https://kixeye.atlassian.net/wiki/display/PF/Comms+PHP+API
	 */
	
	/**
	 * Dispatched when the MessagingController is ready. 
	 */	
	[Event(name="ready", type="com.kixeye.messaging.MessagingControllerEvent")]
	
	/**
	 * Dispatched when a Thread is added. 
	 */	
	[Event(name="threadsadded", type="com.kixeye.messaging.MessagingControllerEvent")]
	
	/**
	 * Dispatched when a Message is added. 
	 */	
	[Event(name="messagesadded", type="com.kixeye.messaging.MessagingControllerEvent")]
	
	/**
	 * Dispatched when the user's ban status has changed.
	 */
	[Event(name="banstatuschange", type="com.kixeye.messaging.MessagingControllerEvent")]
	
	public class MessagingController extends EventDispatcher implements IMessagingDelegate
	{
		protected static const _log:IKXLogger = KXLog.getLoggerForClass(MessagingController);
		
		// Not set to true until we have a list of threads + ignored peeps	
		protected var _isReady:Boolean = false;
		
		// the messaging engine component
		protected var _engine:IMessagingEngine;
		
		// models
		protected var _ignoreList:Vector.<String> = new Vector.<String>();
		protected var _threadIdToThread:Object = {};
		protected var _threadIdToMessagesLoaded:Object = {};
		
		// start with no access
		protected var _banned:Boolean = false;
		protected var _banExpiration:int = 0;
		protected var _banReason:String;
		
		public function MessagingController() {
			
		}
		
		/**
		 * Returns the engine component of the MessagingController.
		 *  
		 * @return 
		 */		
		public function get engine():IMessagingEngine {
			return _engine;
		}
		
		/**
		 * Returns a copy of the list of IDs that we have ignored through
		 * the messaging system. Unfortunately, these are not MessagingUsers
		 * because the PHP API only returns ids.
		 *  
		 * @return 
		 */		
		public function get ignoredIDs():Vector.<String> {
			// return a copy
			return _ignoreList.slice(0);
		}
		
		/**
		 * True if the user is currently banned.
		 *  
		 * @return 
		 */		
		public function get banned():Boolean {
			return _banned;
		}
		
		/**
		 * Returns the timestamp of ban expiration. 0 if never or the user is
		 * not banned.
		 *  
		 * @return 
		 */		
		public function get banExpiration():int {
			return _banExpiration;
		}
		
		/**
		 * Returns the reason for the ban.
		 *  
		 * @return 
		 */		
		public function get banReason():String {
			return _banReason;
		}
		
		/**
		 * Initializes the controller. This must be called before use!
		 * 
		 * This object will dispatch MessagingControllerEvent.READY when
		 * initialization is complete.
		 * 
		 * You may also give a callback to this controller via the ready()
		 * function.
		 * 
		 * @param engine	The IMessagingEngine implementation to use.
		 * @param config	A valid MessagingConfiguration instance.
		 */		
		public function initialize(engine:IMessagingEngine, config:MessagingConfiguration):void {
			// initialize engine (inject self)
			_engine = engine
			_engine.initialize(config.withDelegate(this));
		}
		
		/**
		 * Give this a function to call when the controller is ready. If the
		 * controller is already ready, the callback will be called
		 * immediately.
		 *  
		 * @param callback
		 */		
		public function ready(callback:Function):void {
			if (_isReady) {
				callback();
			} else {
				// Add the listener + use a closure so we capture the value of
				// callback. This way, we don't need to keep a list of
				// callbacks. 
				addEventListener(MessagingControllerEvent.READY,
					function(event:MessagingControllerEvent):void {
						removeEventListener(event.type, arguments.callee);
						
						callback();
					});
			}
		}
		
		/**
		 * Returns whether or not the user is ignored.
		 *  
		 * @param user
		 * @return 
		 */		
		public function isIgnored(user:MessagingUser):Boolean {
			return -1 != _ignoreList.indexOf(user.socialNetworkId);
		}
		
		/**
		 * Returns a list of threads.
		 *  
		 * @param sort	If true, returns sorted by creation time.
		 * @return
		 */		
		public function getThreads(sort:Boolean = false):Vector.<Thread> {
			// build thread list
			var threads:Vector.<Thread> = new Vector.<Thread>();
			for (var id:String in _threadIdToThread) {
				threads.push(_threadIdToThread[id]);
			}
			
			// sort by createtime
			if (sort) {
				threads = threads.sort(
					function (a:Thread, b:Thread):Number {
						return a.createtime - b.createtime;
					});
			}
			
			return threads;
		}
		
		/**
		 * Returns a thread by id.
		 *  
		 * @param id
		 * @return 
		 */		
		public function getThreadById(id:String):Thread {
			return null == id ? null : _threadIdToThread[id];
		}
		
		/**
		 * 
		 * @return The number of threads that have new messages
		 * 
		 */		
		public function getUnreadCount():int {
			var total:int = 0;
			var threads:Vector.<Thread> = getThreads();
			for each (var thread:Thread in threads) {
				if (thread.unreadCount) {
					total += 1;
				}
			}
			return total;
		}
		
		/**
		 * Returns a unordered list of threads that have the given recipients.
		 *   
		 * @param recipients
		 * @return 
		 */		
		public function getThreadsWithRecipients(recipients:Vector.<MessagingUser>, sort:Boolean = false):Vector.<Thread> {
			var returnThreads:Vector.<Thread> = new Vector.<Thread>();
			
			// iterate over all our threads
			var threads:Vector.<Thread> = getThreads(sort);
			for each (var thread:Thread in threads) {
				// only look at threads with a matching number of recipients
				if (thread.recipients.length == recipients.length) {
					// assuming there aren't multiples of the same user in either list...
					var valid:Boolean = true;
					for each (var recipient:MessagingUser in thread.recipients) {
						if (!inRecipients(recipient)) {
							valid = false;
							break;
						}
					}
					
					if (valid) {
						returnThreads.push(thread);
					}
				}
			}
			
			function inRecipients(user:MessagingUser):Boolean {
				for each (var messagingUser:MessagingUser in recipients) {
					if (messagingUser.equals(user)) return true;
				}
				
				return false;
			}
			
			return returnThreads;
		}
		
		/**
		 * Loads threads. This does not load messages in a thread, just the
		 * threads themselves. The callback is NOT called with a response object.
		 * 
		 * @param	callback	This is called when the response returns.
		 * @users	users		A list of users that messages should be loaded for.
		 * @param	history		The total number of threads to load or -1 for all.
		 */
		public function loadThreads(callback:Function, users:Vector.<MessagingUser> = null, history:int = 10):void {
			if (!_isReady) {
				// the api is not ready
				return;
			}
			
			// we may or may not be filtering by id
			var ids:Array = [];
			for each (var user:MessagingUser in users) {
				ids.push(user.socialNetworkId);
			}
			
			// To keep this model consistent + easy, we are not allowing skip
			// to be used. Instead, keep it simple and only specify the total
			// number of threads to load. Internally we will decide how many
			// to skip.
			var skip:int = getThreads().length;
			var limit:int = history - skip;
			
			if (-1 != history && limit <= 0) {
				if (null != callback) {
					callback();
				}
				
				return;
			}
			
			// get threads!
			_engine.sendRequest(
				MessagingEventTypes.GET_THREADS,
				{
					fbids:0 == ids.length ? null : ids.join(","),
					limit:-1 == history ? "all" : limit,
					skip:skip
				},
				function (response:MessagingResponse):void {
					updateBanStatus(response.responseObject);
					
					// use a custom callback
					refreshThreadsCallback(response, callback);
				});
		}
		
		/**
		 * Loads a thread, adds it, calls the callback.
		 * 
		 * @param threadid	The id of the thread to load.
		 * @param callback	This is called when the thread has been loaded. It
		 * is NOT called with a response object.
		 * @param history	The maximum total number of messages to load.
		 */		
		public function loadThread(threadid:String, callback:Function = null, history:int = 10):void {
			// do we *need* to send this request
			var thread:Thread = getThreadById(threadid);
			var messagesLoaded:int = 0;
			if (null != thread) {
				messagesLoaded = _threadIdToMessagesLoaded.hasOwnProperty(threadid) ? _threadIdToMessagesLoaded[threadid] : 0;
				if (messagesLoaded >= history) {
					// we don't need to send this, because it's already loaded
					callback();
					return;
				}
			}
			
			// To keep this model consistent + easy, we are not allowing skip
			// to be used. Instead, keep it simple and only specify the total
			// number of messages to load. Internally we will decide how many
			// to skip.
			var skip:int = messagesLoaded;
			
			// get the thread!
			_engine.sendRequest(
				MessagingEventTypes.GET_THREAD,
				{
					threadid:threadid,
					limit:history - skip,
					skip:skip
				},
				function (response:MessagingResponse):void {
					updateBanStatus(response.responseObject);
					
					if (response.success) {
						addThread(response.responseObject.thread, history);
					}
					
					if (null != callback) callback();
				});
		}
		
		/**
		 * Creates a thread then calls the callback with a MessagingResponse.
		 *  
		 * @param request
		 * @param callback
		 * 
		 * @return	Returns an IDisposable that can be used to cancel the callback. 
		 */		
		public function createThread(request:CreateThreadRequest, callback:Function):IDisposable {
			if (null == request
				|| null == request.recipients
				|| 0 == request.recipients.length) {
				_log.error("Error : invalid CreateThreadRequest. Recipient IDs must be specified.");
				callback(MessagingResponse.failed());
				return new MessagingDisposable();
			}
			
			if (_banned) {
				_log.warn("Error : cannot create threads while banned.");
				callback(MessagingResponse.failed());
				return new MessagingDisposable();
			}
			
			// create request object
			var requestObject:Object = formatRequestObject(request);
			
			// add recipients
			var recipientIDs:Vector.<String> = new Vector.<String>();
			var map:Object = {};
			for each (var recipient:MessagingUser in request.recipients) {
				recipientIDs.push(recipient.socialNetworkId);
				map[recipient.socialNetworkId] = recipient.displayName;
			}
			requestObject.recipients = recipientIDs.join(",");
			
			// add me to the map
			map[_engine.config.user.socialNetworkId] = _engine.config.user.displayName;
			// Not losing the extradata passed with the request
			for ( var key:String in request.extraData )
			{
				map[key] = request.extraData[key];
			}
			requestObject.thread_headers = JSON.encode(map);
			
			// return a diposable
			return sendRequestWithInternalCallback(
				request.eventType,
				requestObject,
				callback,
				function (response:MessagingResponse):void {
					if (response.success) {
						// add new thread (add a couple properties to it)
						requestObject.threadid = response.responseObject.data.threadid;
						requestObject.createtime = requestObject.updatetime = response.responseObject.data.createtime;
						requestObject.recipients = requestObject.recipients.split(",");
						addThread(requestObject);
					}
				});
		}
		
		/**
		 * Replies to a thread then calls the callback with a MessagingResponse.
		 *  
		 * @param request
		 * @param callback
		 * 
		 * @return	Returns an IDisposable that can be used to cancel the callback. 
		 */		
		public function replyToThread(request:ReplyToThreadRequest, callback:Function):IDisposable {
			if (null == request || null == request.threadId) {
				_log.error("Error : invalid ReplyToThreadRequest. ThreadId must be specified.");
				callback(MessagingResponse.failed());
				return new MessagingDisposable();
			}
			
			if (_banned) {
				_log.warn("Error : cannot reply to threads while banned.");
				callback(MessagingResponse.failed());
				return new MessagingDisposable();
			}
			
			// create request object
			var requestObject:Object = formatRequestObject(request);
			requestObject.threadid = request.threadId;
			
			// return the disposable
			return sendRequestWithInternalCallback(
				request.eventType,
				requestObject,
				callback,
				function (response:MessagingResponse):void {
					// add this to the model (we don't get an event for ourselves
					if (response.success) {
						// we have to inject a couple things!
						requestObject.from = String(_engine.config.user.socialNetworkId);
						requestObject.createtime = response.responseObject.data.createtime;
						addNewMessage(requestObject);
					}
				});
		}
		
		/**
		 * Ignores or unignores a list of users. Callback is called with a
		 * MessagingResponse instance.
		 *  
		 * @param ids
		 * @param ignore	True to ignore, false to unignore.
		 * @param callback
		 * 
		 */		
		public function setIgnoreOnUsers(ids:Vector.<String>, ignore:Boolean, callback:Function = null):IDisposable {
			if (null == _engine) {
				if (null != callback) {
					callback(MessagingResponse.failed());
				}
				return new MessagingDisposable();
			}
			
			if (null == ids || 0 == ids.length) {
				_log.warn("Error : invalid ids.");
				if (null != callback) {
					callback(MessagingResponse.failed());
				}
				return new MessagingDisposable();
			}
			
			// trim the fbids to only ones we need
			ids = trimIgnoreIDS(ids, ignore);
			
			// if there are no changes, don't send the request
			if (0 == ids.length) {
				if (null != callback) {
					callback(MessagingResponse.success());
				}
				return new MessagingDisposable();
			}
			
			// send request
			return sendRequestWithInternalCallback(
				ignore ? MessagingEventTypes.IGNORE_USERS : MessagingEventTypes.UNIGNORE_USERS,
				{
					// TODO: API should not take FBIDs as they may be kixids!
					fbids : ids.join(",")
				},
				callback,
				function (response:MessagingResponse):void {
					updateInternalIgnoreModel(response, ids);
					
					// remove all threads from those people
					if (ignore) {
						for each (var id:String in ids) {
							removeThreadsFrom(id);
						}
					} else {
						// send a get threads request to get the threads from
						// these users
						_engine.sendRequest(
							MessagingEventTypes.GET_THREADS,
							{
								limit:"all",
								skip:0,
								fbids:ids.join(",")
							},
							function (response:MessagingResponse):void {
								refreshThreadsCallback(response, function():void {
									if (null != callback) {
										callback(MessagingResponse.success());
									}
								});
							});
					}
				});
		}
		
		/**
		 * IMessagingDelegate
		 * 
		 * Processes the ready event.
		 *  
		 * @param responseObject
		 */		
		public function processReady(response:MessagingResponse):void {
			_isReady = true;
			
			// get ALL threads!
			loadThreads(
				function():void {
					// now get the ignore list
					getIgnoreList(
						function(ignoreListResponse:MessagingResponse):void {
							if (!ignoreListResponse.success) {
								_log.error("Error : could not get ignore list.");
							} else {
								// process the ignored list
								var ignored:Array = ignoreListResponse.responseObject.ignored_users;
								for each (var ignoredID:String in ignored) {
									_ignoreList.push(ignoredID);
								}
							}
							
							// tell the world we're loaded + ready
							dispatchEvent(new MessagingControllerEvent(MessagingControllerEvent.READY));
						});
				}, null, -1);
		}
		
		/**
		 * IMessagingDelegate
		 * 
		 * Handles a pushed event.
		 *  
		 * @param response
		 * 
		 */		
		public function processPush(response:MessagingResponse):void {
			// don't do anything if this wasn't successful (all push events should be...)
			// TODO: add this check back in once server bug is gone
			//if (!response.success) return;
			
			switch (response.eventType) {
				case MessagingEventTypes.PUSH_NEW_MESSAGE:
				{
					// add a new message
					addNewMessage(response.responseObject);
					break;
				}
				case MessagingEventTypes.PUSH_NEW_THREAD:
				{
					// add a new thread
					addThread(response.responseObject);
					break;
				}
					
				// other push events?
			}
		}
		
		/**
		 * Sends a request through the engine with an internal callback. This
		 * callback is always called, regardless of whether or not an external
		 * system disposes of the IDisposable returned to it.
		 *  
		 * @param event
		 * @param data
		 * @param callback
		 * @param internalCallback
		 * @return 
		 */		
		protected function sendRequestWithInternalCallback(event:String, data:Object, callback:Function, internalCallback:Function):IDisposable {
			// create a disposable here
			var disposable:MessagingControllerDisposable = new MessagingControllerDisposable();
			
			// now call the engine with our wrapped function
			_engine.sendRequest(event, data, wrap(callback, internalCallback));
			
			function wrap(callback:Function, internalCallback:Function):Function {
				return function(response:MessagingResponse):void {
					// check if we're banned, dawg
					updateBanStatus(response.responseObject);
					
					// call the internal function
					internalCallback(response);
					
					// if the disposable has not been disposed, call the callback
					if (!disposable.disposed && null != callback) {
						callback(response);
					}
				};
			}
			
			// return the custom IDisposable
			return disposable;
		}
		
		/**
		 * Gets the list of ignored FBIDs. This is called internally.
		 *  
		 * @param callback
		 */		
		protected function getIgnoreList(callback:Function):void {
			_engine.sendRequest(
				MessagingEventTypes.GET_IGNORELIST,
				{
					// no params
				},
				callback);
		}
		
		/**
		 * Trims IDs passed into ignoreUsers.
		 *  
		 * @param ids
		 * @param ignore
		 * @return
		 */		
		protected function trimIgnoreIDS(ids:Vector.<String>, ignore:Boolean):Vector.<String> {
			var neededIds:Vector.<String> = new Vector.<String>();
			for each (var id:String in ids) {
				// determines if this fbid is already ignored or not
				var ignored:Boolean = -1 != _ignoreList.indexOf(id);
				if (ignore && ignored) {
					// do not request an ignore for an already ignored user
					continue;
				} else if (!ignore && !ignored) {
					// do not request an unignore for a user that is not
					// ignored
					continue;
				}
				
				// we need this id
				neededIds.push(id);
			}
			
			return neededIds;
		}
		
		/**
		 * Updates the ignored list from an ignored response.
		 *  
		 * @param response
		 * @param ignore
		 * @param ids
		 * 
		 */		
		protected function updateInternalIgnoreModel(response:MessagingResponse, ids:Vector.<String>):void {
			// only update the model if the request was successful
			if (response.success) {
				if (MessagingEventTypes.IGNORE_USERS == response.eventType) {
					// add these to the ignore list
					_ignoreList = _ignoreList.concat(ids);
				} else {
					// remove these from the ignore list
					var ignoreList:Vector.<String> = new Vector.<String>();
					for each (var ignoredID:String in _ignoreList) {
						if (-1 == ids.indexOf(ignoredID)) {
							ignoreList.push(ignoredID);
						}
					}
					_ignoreList = ignoreList;
				}
			}
		}
		
		/**
		 * Formats a request object to be sent through the JS API.
		 *  
		 * @param request
		 * @return 
		 * 
		 */		
		protected function formatRequestObject(request:MessagingRequest):Object {
			return {
				subject : request.subject,
				message : request.message,
				type : request.type
			};
		}
		
		protected function setBan(banned:Boolean, expiration:int, reason:String):void {
			// dispatch only if value changed
			if (_banned == banned) {
				return;
			}
			
			_banned = banned;
			_banExpiration = expiration;
			_banReason = reason;
			
			dispatchEvent(new MessagingControllerEvent(MessagingControllerEvent.BAN_STATUS_CHANGE));
		}
		
		/**
		 * Called with the response for getthreads. Populates the appropriate
		 * models.
		 *  
		 * @param response
		 */		
		protected function refreshThreadsCallback(response:MessagingResponse, callback:Function):void {
			if (!response.success) {
				_log.error("Could not get threads!");
				return;
			}
			
			// create necessary threads!
			var threads:Array = response.responseObject.threads;
			for each (var threadObject:Object in threads) {
				addThread(threadObject);
			}
			
			if (null != callback) {
				callback();
			}
		}
		
		/**
		 * Updates the user's ban status when a response is recieved. If ban
		 * status is changed, a MessagingControllerEvent.BAN_STATUS_CHANGE
		 * will be dispatched.
		 *  
		 * @param response
		 */		
		protected function updateBanStatus(response:Object):void {
			if (!response.hasOwnProperty("banned")) {
				return;
			}
			
			// I'm paranoid, so check explicitly against false as this key
			// may not exist in old versions
			if (false == response.banned) {
				setBan(false, 0, null);
			} else {
				var banExpireValue:String = response.banned.banned;
				setBan(
					true,
					"inf" == banExpireValue ? 0 : int(banExpireValue),
					response.banned.message);
			}
		}
		
		/**
		 * Safely adds a message to a thread.
		 *  
		 * @param threadid
		 * @param messageObject
		 * @return 
		 * 
		 */
		protected function addNewMessage(messageObject:Object):void {
			// try to add it to an existing thread
			// if it does not exist, load it first
			if (!add()) {
				loadThread(
					messageObject.threadid,
					add);
			}
			
			// adds to a thread
			function add():Boolean {
				if (_threadIdToThread.hasOwnProperty(messageObject.threadid)) {
					// grab message + thread
					var message:Message = Message.MessageFromJSON(messageObject);
					var thread:Thread = _threadIdToThread[messageObject.threadid];
					
					// if this is from me, it is read
					if (message.fromID == _engine.config.user.socialNetworkId) {
						thread.addReadMessage(message);
					} else {
						thread.addUnreadMessage(message);
					}
					
					// dispatch an event, but not on initial load
					if (_isReady) {
						dispatchEvent(new MessagingControllerEvent(MessagingControllerEvent.MESSAGES_ADDED, thread.id, message));
					}
					
					return true;
				}
				
				return false;
			}
		}
		
		/**
		 * Creates threads when necessary + adds messages when not.
		 * 
		 * @param threadObject
		 * @param loaded		The total number of messages loaded.
		 */		
		protected function addThread(threadObject:Object, loaded:int = 0):void {
			var threadid:String = threadObject.threadid;
			
			// add new messages to existing thread
			if (_threadIdToThread.hasOwnProperty(threadid)) {
				_threadIdToThread[threadid].update(threadObject);
				_threadIdToMessagesLoaded[threadid] = loaded;
				return;
			}
			
			// create thread
			var thread:Thread = Thread.ThreadFromJSON(threadObject);
			
			// add me!
			thread.addRecipient(_engine.config.user);
			
			_threadIdToMessagesLoaded[threadid] = loaded;
			_threadIdToThread[threadid] = thread;
			
			// dispatch an event, but not on initial load
			if (_isReady) {
				dispatchEvent(new MessagingControllerEvent(MessagingControllerEvent.THREADS_ADDED, threadid));
			}
		}
		
		/**
		 * Removes threads from a specific id.
		 *  
		 * @param id
		 */		
		protected function removeThreadsFrom(id:String):void {
			var thread:Thread;
			var recipients:Vector.<MessagingUser>;
			for (var threadid:String in _threadIdToThread) {
				thread = _threadIdToThread[threadid];
				
				recipients = thread.recipients;
				for each (var recipient:MessagingUser in recipients) {
					if (id == recipient.socialNetworkId) {
						delete _threadIdToThread[threadid];
						break;
					}
				}
			}
		}
	}
}